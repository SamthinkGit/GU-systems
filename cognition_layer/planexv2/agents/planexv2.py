"""
PlanexV2 Module
==============================

This module handles the iterative processing of input queries through a series of
agents: Planner, Reducer, Translator, and Blamer. It manages the interactions and
data flow between these agents to generate a cohesive response, with an emphasis
on error handling and iterative improvement through the Blamer agent.

This module is aimed to be used as Cognition Layer providing an iterator for
using all the agents and easily deploying it with the ServerFromIterator module
(cognition_layer.tools.server_template)
"""
import traceback
from dataclasses import dataclass
from typing import Generator

import ecm.exelent.parser as exelent_parser
from cognition_layer.planex.agents.planner import Planner
from cognition_layer.planex.agents.reducer import Reducer
from cognition_layer.planex.agents.translator import Translator
from cognition_layer.planex.utils.format import extract_python_code
from cognition_layer.planexv2.agents.blamer import BlameInfo
from cognition_layer.planexv2.agents.blamer import Blamer
from cognition_layer.planexv2.agents.blamer import ClassificationResponse
from ecm.exelent.verify import verify_valid_actions
from ecm.shared import get_logger


@dataclass
class PlanexV2Message:
    """
    Represents a message passed between agents in the PlanexV2 processing
    workflow. It contains details about the current and next agent, the query
    being processed, the content of the message, whether it's the last step,
    and the number of steps taken.

    :param agent: The name of the current agent processing the query.
    :param next_agent: The name of the next agent to process the query.
    :param query: The original query being processed.
    :param content: The content generated by the current agent.
    :param is_last: Boolean indicating if this is the last processing step.
    :param steps: The number of steps taken in processing the query.
    """

    agent: str
    next_agent: str
    query: str
    content: str
    is_last: bool
    steps: int


class PlanexV2:

    _logger = get_logger("PlanexV2")

    def __init__(self) -> None:
        """
        The PlanexV2 class orchestrates the interaction between the Planner,
        Reducer, Translator, and Blamer agents to process input queries. It
        manages the iterative workflow, ensures proper data handling between
        agents, and incorporates ERROR HANDLING and recovery through the Blamer
        agent.
        """

        self.planner = Planner()
        self.reducer = Reducer()
        self.translator = Translator()
        self.blamer = Blamer()

    def iter(
        self,
        input: str,
        verbose: bool = False,
        max_steps: int = 10,
        _steps: int = 0,
        _planner_previous_output: str = None,
        _reducer_previous_output: str = None,
    ) -> Generator[PlanexV2Message, None, None]:
        """
        Iteratively processes the input query through the Planner, Reducer,
        Translator, and Blamer agents, yielding PlanexV2Message objects at
        each step. Handles agent output and manages error recovery using the
        Blamer agent when necessary.

        :param input: The original input query to be processed.
        :param verbose: Flag to enable verbose logging of the processing steps.
        :param max_steps: Maximum number of steps to process the query.
        :param _steps: Internal counter for the current processing step.
        :param _planner_previous_output: Previous output from the Planner agent.
        :param _reducer_previous_output: Previous output from the Reducer agent.
        :return: A generator yielding PlanexV2Message objects for each processing
                 step.

        There is an example for the usage of this function in tests/sandbox/planex.v2.iter.py
        """

        if _steps > max_steps:
            raise RuntimeError("Maximum steps reached. Abort")

        original_query = input
        steps = _steps

        # This function is recursive, so previous output can be self generated
        if not _planner_previous_output:

            # Yield Planner Step
            planner_output = self.planner.plan(input, verbose=verbose).content
            input = planner_output
            steps += 1
            yield PlanexV2Message(
                "planner",
                "reducer",
                original_query,
                planner_output,
                is_last=False,
                steps=steps,
            )
        else:
            planner_output = _planner_previous_output

        if not _reducer_previous_output:

            # Yield Reducer Step
            self.reducer.auto_bind_actions()
            reducer_output = self.reducer.reduce(input, verbose=verbose).content
            input = reducer_output
            steps += 1
            yield PlanexV2Message(
                "reducer",
                "translator",
                original_query,
                reducer_output,
                is_last=False,
                steps=steps,
            )
        else:
            reducer_output = _reducer_previous_output

        # Generate Translator Step
        translator_output = self.translator.translate(input, verbose=verbose).content
        steps += 1
        task = None

        # Checking if Exelent file is correct
        try:
            if translator_output.startswith("```python"):
                translator_output = extract_python_code(translator_output)
            task = exelent_parser.parse(target_str=translator_output)
            verify_valid_actions(task)

        except Exception:

            # It is not correct, calling blamer
            self._logger.debug(
                "Task generated by Planex failed verification, calling to Blamer."
            )
            # Yield Translator Step (Not finished)
            yield PlanexV2Message(
                "translator",
                "blamer",
                original_query,
                translator_output,
                is_last=False,
                steps=steps,
            )
            blame = BlameInfo(
                query=original_query,
                planner_output=planner_output,
                reducer_output=reducer_output,
                translator_output=translator_output,
                reducer_tools=self.reducer.actions,
                additional_info=traceback.format_exc(),
            )
            response: ClassificationResponse = self.blamer.run(blame, verbose=verbose)
            steps += 1

            # Yield Blamer Step (Finished)
            yield PlanexV2Message(
                "blamer",
                response.blame,
                original_query,
                response.blame,
                is_last=False,
                steps=steps,
            )

            # Check the blame is valid
            response.blame = response.blame.lower()
            if response.blame not in ["planner", "reducer", "translator"]:
                raise SystemError(
                    "Blamer could not find the error on the plan (Returned invalid Step), please revise the query."
                )
            _planner_previous_output = None
            _reducer_previous_output = None

            # Use recursively until generating a plan or reaching max steps
            match response.blame:
                case "planner":
                    query = original_query
                case "reducer":
                    query = planner_output
                    _planner_previous_output = planner_output
                case "translator":
                    _planner_previous_output = planner_output
                    _reducer_previous_output = reducer_output
                    query = reducer_output

            yield from self.iter(
                input=query + "\nAdvise: " + response.advise,
                verbose=verbose,
                max_steps=max_steps,
                _steps=steps,
                _planner_previous_output=_planner_previous_output,
                _reducer_previous_output=_reducer_previous_output,
            )

        # Yield Translator Step (Finished)
        yield PlanexV2Message(
            "translator",
            None,
            original_query,
            translator_output,
            is_last=True,
            steps=steps,
        )
        return
